import fs from 'node:fs'
import path from 'node:path'

import { prisma } from '../src/lib/prisma'
import { loadDotEnvFiles } from './ingest-utils'

import type { RegistryProviderMapping, RegistryRoleMember, RegistrySymbol, SymbolRegistrySnapshot } from '../src/lib/symbol-registry/types'

const PRIMARY_SYMBOL_ROLE = 'INNGEST_MES_ONLY'
const OUTPUT_PATH = path.resolve(process.cwd(), 'src/lib/symbol-registry/snapshot.ts')
const JSON_OUTPUT_PATH = path.resolve(process.cwd(), 'src/lib/symbol-registry/snapshot.json')

type DbRoleMemberRow = {
  role_key: string
  symbol_code: string
  position: number
  enabled: boolean
}

function toRegistrySymbol(raw: {
  code: string
  displayName: string
  shortName: string | null
  description: string | null
  tickSize: { toString(): string }
  dataSource: RegistrySymbol['dataSource']
  dataset: string | null
  databentoSymbol: string | null
  fredSymbol: string | null
  isActive: boolean
}): RegistrySymbol {
  return {
    code: raw.code,
    displayName: raw.displayName,
    shortName: raw.shortName,
    description: raw.description,
    tickSize: Number(raw.tickSize.toString()),
    dataSource: raw.dataSource,
    dataset: raw.dataset,
    databentoSymbol: raw.databentoSymbol,
    fredSymbol: raw.fredSymbol,
    isActive: raw.isActive,
  }
}

function toRegistryProviderMapping(raw: {
  symbolCode: string
  source: RegistryProviderMapping['source']
  sourceTable: string
  sourceSymbol: string
  isPrimary: boolean
  confidenceScore: { toString(): string } | null
  notes: string | null
}): RegistryProviderMapping {
  return {
    symbolCode: raw.symbolCode,
    source: raw.source,
    sourceTable: raw.sourceTable,
    sourceSymbol: raw.sourceSymbol,
    isPrimary: raw.isPrimary,
    confidenceScore: raw.confidenceScore ? Number(raw.confidenceScore.toString()) : null,
    notes: raw.notes,
  }
}

function renderSnapshotTs(snapshot: SymbolRegistrySnapshot): string {
  const json = JSON.stringify(snapshot, null, 2)
  return `/* eslint-disable */\n` +
    `// AUTO-GENERATED by scripts/generate-symbol-registry-snapshot.ts\n` +
    `// Do not edit by hand. Regenerate with: npm run registry:snapshot\n\n` +
    `import type { SymbolRegistrySnapshot } from './types'\n\n` +
    `export const SYMBOL_REGISTRY_SNAPSHOT: SymbolRegistrySnapshot = ${json}\n`
}

async function loadRoleMembers(): Promise<RegistryRoleMember[]> {
  try {
    const rows = await prisma.$queryRaw<DbRoleMemberRow[]>`
      SELECT m.role_key, m.symbol_code, m.position, m.enabled
      FROM symbol_role_members m
      JOIN symbol_roles r ON r.role_key = m.role_key
      WHERE r.is_active = true
      ORDER BY m.role_key ASC, m.position ASC, m.symbol_code ASC
    `
    return rows.map((row) => ({
      roleKey: row.role_key,
      symbolCode: row.symbol_code,
      position: Number(row.position),
      enabled: Boolean(row.enabled),
    }))
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    if (message.includes('symbol_role_members') || message.includes('symbol_roles') || message.includes('does not exist')) {
      console.warn(
        `[registry:snapshot] role tables unavailable; writing snapshot without role memberships: ${message}`,
      )
      return []
    }
    throw error
  }
}

function resolvePrimarySymbol(symbols: RegistrySymbol[], roleMembers: RegistryRoleMember[]): string {
  const primaryMember = roleMembers.find((member) => member.roleKey === PRIMARY_SYMBOL_ROLE && member.enabled)
  if (primaryMember) return primaryMember.symbolCode

  const mes = symbols.find((symbol) => symbol.code === 'MES' && symbol.isActive)
  if (mes) return mes.code

  throw new Error('[registry:snapshot] unable to resolve primary symbol from role members or active MES')
}

async function main(): Promise<void> {
  loadDotEnvFiles()

  const symbols = (
    await prisma.symbol.findMany({
      orderBy: { code: 'asc' },
    })
  ).map(toRegistrySymbol)

  if (symbols.length === 0) {
    throw new Error('[registry:snapshot] symbols table returned zero rows')
  }

  const roleMembers = await loadRoleMembers()

  const providerMappings = (
    await prisma.symbolMapping.findMany({
      orderBy: [{ symbolCode: 'asc' }, { source: 'asc' }, { sourceTable: 'asc' }, { sourceSymbol: 'asc' }],
    })
  ).map(toRegistryProviderMapping)

  const snapshot: SymbolRegistrySnapshot = {
    generatedAt: new Date().toISOString(),
    primarySymbol: resolvePrimarySymbol(symbols, roleMembers),
    symbols,
    roleMembers,
    providerMappings,
  }

  const contents = renderSnapshotTs(snapshot)
  fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true })
  fs.writeFileSync(OUTPUT_PATH, contents, 'utf8')
  fs.writeFileSync(JSON_OUTPUT_PATH, JSON.stringify(snapshot, null, 2), 'utf8')

  console.log(
    `[registry:snapshot] wrote ${OUTPUT_PATH} with ${snapshot.symbols.length} symbols, ` +
      `${snapshot.roleMembers.length} role memberships, ${snapshot.providerMappings.length} provider mappings`,
  )
  console.log(`[registry:snapshot] wrote ${JSON_OUTPUT_PATH} (JSON for Python scripts)`)
}

main()
  .catch((error) => {
    console.error('[registry:snapshot] failed:', error)
    process.exitCode = 1
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
