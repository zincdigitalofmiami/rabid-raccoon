import { NextRequest, NextResponse } from 'next/server'
import fs from 'node:fs'
import path from 'node:path'

/**
 * ML Forecast API â€” serves pre-computed predictions from public/ml-predictions.json
 *
 * Predictions are generated by running:
 *   .venv-autogluon/bin/python scripts/predict.py --rows=24 --output=public/ml-predictions.json
 *
 * This route simply reads and serves that file.
 */

const PREDICTIONS_PATH = path.join(process.cwd(), 'public', 'ml-predictions.json')

interface MLPrediction {
  timestamp: string
  price: number | null
  prob_up_1h: number | null
  prob_up_4h: number | null
  prob_up_1d: number | null
  prob_up_1w: number | null
  direction_1h: string | null
  direction_4h: string | null
  direction_1d: string | null
  direction_1w: string | null
  confidence_1h: number | null
  confidence_4h: number | null
  confidence_1d: number | null
  confidence_1w: number | null
  model_agreement_1h: number | null
  model_agreement_4h: number | null
  model_agreement_1d: number | null
  model_agreement_1w: number | null
  calibrated: boolean
  cal_methods?: Record<string, string>
}

interface MLPredictionResponse {
  predictions: MLPrediction[]
  meta: {
    model_dir: string
    dataset: string
    folds_loaded: Record<string, number>
    n_features: number
    dataset_rows: number
    generated_at: string
  }
}

function readPredictions(): MLPredictionResponse | null {
  try {
    if (!fs.existsSync(PREDICTIONS_PATH)) return null
    const raw = fs.readFileSync(PREDICTIONS_PATH, 'utf8')
    return JSON.parse(raw) as MLPredictionResponse
  } catch {
    return null
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const rows = Number(searchParams.get('rows') || '1')

    const data = readPredictions()

    if (!data) {
      return NextResponse.json(
        {
          error: 'No ML predictions available',
          hint: 'Run: .venv-autogluon/bin/python scripts/predict.py --rows=24 --output=public/ml-predictions.json',
        },
        { status: 503 }
      )
    }

    // Return latest N predictions
    const predictions = data.predictions.slice(-rows)
    const latest = predictions[predictions.length - 1]

    // How old are these predictions?
    const generatedAt = new Date(data.meta.generated_at)
    const ageMinutes = Math.round((Date.now() - generatedAt.getTime()) / 60000)

    return NextResponse.json({
      latest,
      predictions,
      meta: data.meta,
      stale: ageMinutes > 120,
      age_minutes: ageMinutes,
    }, {
      headers: {
        'Cache-Control': 's-maxage=60, stale-while-revalidate=300',
      },
    })
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error)
    console.error(`[ml-forecast] error: ${msg}`)
    return NextResponse.json({ error: msg }, { status: 500 })
  }
}
