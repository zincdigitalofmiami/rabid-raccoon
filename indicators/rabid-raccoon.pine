// This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© Kirk / ZINC Digital
// @version=6

indicator("Rabid Raccoon", shorttitle="ü¶ù RR", overlay=true, max_lines_count=500, max_labels_count=500, max_boxes_count=500)

//#region === INPUTS & CONFIGURATION ===

// --- Feature Toggles ---
showMeasuredMoves   = input.bool(true,  "Show Measured Moves",      group="Feature Toggles")
showAutoFib         = input.bool(true,  "Show Auto-Fibonacci",      group="Feature Toggles")
showBreakHookGo     = input.bool(true,  "Show Break-Hook-Go",       group="Feature Toggles")
showCorrelation     = input.bool(false, "Show Correlation Analysis", group="Feature Toggles")
showRiskManagement  = input.bool(true,  "Show Risk Management",     group="Feature Toggles")
debugMode           = input.bool(false, "Debug Mode",               group="Feature Toggles")

// --- Measured Move Settings ---
mmLookback          = input.int(20,     "Swing Lookback Period",    minval=5, maxval=100, group="Measured Moves")
mmTolerance         = input.float(0.1,  "Move Equality Tolerance",  minval=0.01, maxval=0.5, step=0.01, group="Measured Moves")

// --- Fibonacci Settings (Multi-Period Confluence) ---
// Uses Fibonacci-sequence lookback periods (8, 13, 21, 34, 55) to find the
// highest-confluence anchor ‚Äî matching TSoFib methodology.
fibExtendRight      = input.bool(true,  "Extend Right",             group="Fibonacci")
fibShowPrices       = input.bool(true,  "Show Prices",              group="Fibonacci")
fibShowLevels       = input.bool(true,  "Show Levels",              group="Fibonacci")
fibShowExtensions   = input.bool(true,  "Show Extensions",          group="Fibonacci")
fibBgTransparency   = input.int(85,     "Background Transparency",  minval=0, maxval=100, group="Fibonacci")
fibEntryLabels      = input.bool(false, "Show Entry Labels",        group="Fibonacci")

// --- Break-Hook-Go Settings ---
bhgSensitivity      = input.int(3,      "BHG Sensitivity",          minval=1, maxval=10, group="Break-Hook-Go")
bhgPullbackFib      = input.float(0.5,  "Pullback Fib Threshold",   minval=0.3, maxval=0.786, step=0.01, group="Break-Hook-Go")
bhgShowLabels       = input.bool(false, "Show BHG Labels",          group="Break-Hook-Go")

// --- Correlation Settings ---
corrSymbol1         = input.symbol("VIX",    "Correlation Symbol 1", group="Correlation")
corrSymbol2         = input.symbol("DXY",    "Correlation Symbol 2", group="Correlation")
corrSymbol3         = input.symbol("NQ1!",   "Correlation Symbol 3", group="Correlation")
corrPeriod          = input.int(20,          "Correlation Period",   minval=5, maxval=100, group="Correlation")

// --- Risk Management Settings ---
riskAccountSize     = input.float(10000, "Account Size ($)",         minval=100, group="Risk Management")
riskPerTrade        = input.float(1.0,   "Risk Per Trade (%)",       minval=0.1, maxval=10.0, step=0.1, group="Risk Management")
riskTickValue       = input.float(1.25,  "Tick Value ($)",           group="Risk Management")  // MES = $1.25/tick

// --- Swing Detection Settings ---
swingLeftBars       = input.int(5,      "Swing Left Bars",          minval=1, maxval=20, group="Swing Detection")
swingRightBars      = input.int(5,      "Swing Right Bars",         minval=1, maxval=20, group="Swing Detection")
swingMaxHistory     = input.int(50,     "Max Swing History",        minval=10, maxval=200, group="Swing Detection")
debugSwingMarkers   = input.bool(false, "Debug: Show Swing Markers", group="Swing Detection")

//#endregion


//#region === USER-DEFINED TYPES ===

type SwingPoint
    float   price
    int     barIdx
    bool    isHigh

type MeasuredMove
    SwingPoint  legA_start
    SwingPoint  legA_end
    SwingPoint  legB_start
    float       projectedTarget
    bool        isBullish
    bool        isActive

type FibLevel
    float   ratio
    float   price
    string  label
    color   clr

type FibSet
    SwingPoint  swingHigh
    SwingPoint  swingLow
    array<FibLevel> levels
    array<FibLevel> extensions

type RiskProfile
    float   entryPrice
    float   stopLoss
    float   target
    float   positionSize
    float   riskReward
    float   dollarRisk

type CorrelationData
    string  symbol
    float   coefficient
    float   currentPrice
    float   percentChange

//#endregion


//#region === CORE UTILITIES (Swing Detection) ===

// Shared swing high/low detection used by multiple modules

// --- Persistent Storage ---
var array<SwingPoint> swingHighs = array.new<SwingPoint>()
var array<SwingPoint> swingLows  = array.new<SwingPoint>()

// --- Pivot Detection ---
pivotHi = ta.pivothigh(high, swingLeftBars, swingRightBars)
pivotLo = ta.pivotlow(low,  swingLeftBars, swingRightBars)

// --- Store Confirmed Swing Highs ---
if not na(pivotHi)
    newHigh = SwingPoint.new(pivotHi, bar_index - swingRightBars, true)
    array.unshift(swingHighs, newHigh)
    if array.size(swingHighs) > swingMaxHistory
        array.pop(swingHighs)

// --- Store Confirmed Swing Lows ---
if not na(pivotLo)
    newLow = SwingPoint.new(pivotLo, bar_index - swingRightBars, false)
    array.unshift(swingLows, newLow)
    if array.size(swingLows) > swingMaxHistory
        array.pop(swingLows)

// --- Convenience: Latest Swing High / Low ---
latestSwingHighPrice = array.size(swingHighs) > 0 ? array.get(swingHighs, 0).price  : na
latestSwingHighBar   = array.size(swingHighs) > 0 ? array.get(swingHighs, 0).barIdx : int(na)
latestSwingLowPrice  = array.size(swingLows)  > 0 ? array.get(swingLows, 0).price   : na
latestSwingLowBar    = array.size(swingLows)  > 0 ? array.get(swingLows, 0).barIdx  : int(na)

// --- Helper: Find Nearest Swing to a Given Bar ---
findNearestSwing(int targetBar) =>
    SwingPoint result = na
    int bestDist = 999999
    if array.size(swingHighs) > 0
        for i = 0 to array.size(swingHighs) - 1
            SwingPoint sp = array.get(swingHighs, i)
            int dist = math.abs(sp.barIdx - targetBar)
            if dist < bestDist
                bestDist := dist
                result   := sp
    if array.size(swingLows) > 0
        for i = 0 to array.size(swingLows) - 1
            SwingPoint sp = array.get(swingLows, i)
            int dist = math.abs(sp.barIdx - targetBar)
            if dist < bestDist
                bestDist := dist
                result   := sp
    result

// --- Debug: Swing Markers ---
if debugSwingMarkers
    if not na(pivotHi)
        label.new(bar_index - swingRightBars, pivotHi, "‚ñº", style=label.style_none, textcolor=color.red, size=size.tiny)
    if not na(pivotLo)
        label.new(bar_index - swingRightBars, pivotLo, "‚ñ≤", style=label.style_none, textcolor=color.green, size=size.tiny)

//#endregion


//#region === EHLERS DBLsmooth StochRSI (EDSS) ===

// Replaces: standard RSI + stoch_14
// DSP-based: roofing filter isolates tradeable cycles, super smoother removes noise
// Computes on the current timeframe ‚Äî use on 15m, 1H, and 4H charts

// --- Inputs ---
edssLength       = input.int(14,  "EDSS Stoch Length",    minval=2,                          group="Ehlers Stochastic")
edssSignalLength = input.int(3,   "EDSS Signal MA Length", minval=1,                          group="Ehlers Stochastic")
edssRoofUpper    = input.int(48,  "EDSS Roofing Upper",   minval=2,                          group="Ehlers Stochastic")
edssRoofLower    = input.int(10,  "EDSS Roofing Lower",   minval=2,                          group="Ehlers Stochastic")
edssOB           = input.float(0.8, "EDSS Overbought",    minval=0.0, maxval=1.0, step=0.05, group="Ehlers Stochastic")
edssOS           = input.float(0.2, "EDSS Oversold",      minval=0.0, maxval=1.0, step=0.05, group="Ehlers Stochastic")

// --- Constants ---
float EDSS_PI = 3.14159265359

// --- Ehlers Super Smoother Filter ---
// Two-pole Butterworth: half the lag of equivalent EMA/SMA
_edssSuperSmoother(float price, int lower) =>
    float a1     = math.exp(-EDSS_PI * math.sqrt(2.0) / lower)
    float coeff2 = 2.0 * a1 * math.cos(math.sqrt(2.0) * EDSS_PI / lower)
    float coeff3 = -math.pow(a1, 2)
    float coeff1 = 1.0 - coeff2 - coeff3
    var float filt = 0.0
    filt := coeff1 * (price + nz(price[1])) / 2.0 + coeff2 * nz(filt[1]) + coeff3 * nz(filt[2])
    filt

// --- Ehlers Roofing Filter ---
// Highpass strips trend (cycles > upper), super smoother strips noise (cycles < lower)
_edssRoofingFilter(float price, int upper, int lower) =>
    float alpha1 = (math.cos(math.sqrt(2.0) * EDSS_PI / upper) + math.sin(math.sqrt(2.0) * EDSS_PI / upper) - 1.0) / math.cos(math.sqrt(2.0) * EDSS_PI / upper)
    var float highpass = 0.0
    highpass := math.pow(1.0 - alpha1 / 2.0, 2) * (price - 2.0 * nz(price[1]) + nz(price[2])) +
                2.0 * (1.0 - alpha1) * nz(highpass[1]) - math.pow(1.0 - alpha1, 2) * nz(highpass[2])
    _edssSuperSmoother(highpass, lower)

// --- Ehlers Stochastic Core ---
_edssStochastic(float price, int len, int upper, int lower) =>
    float filt     = _edssRoofingFilter(price, upper, lower)
    float highestP = ta.highest(filt, len)
    float lowestP  = ta.lowest(filt, len)
    (highestP - lowestP) != 0 ? (filt - lowestP) / (highestP - lowestP) : 0.0

// --- Computed Values ---
float edssRaw    = _edssStochastic(close, edssLength, edssRoofUpper, edssRoofLower)
float edssStoch  = _edssSuperSmoother(edssRaw, edssRoofLower)
float edssSignal = ta.sma(edssStoch, edssSignalLength)

// --- Derived Signals ---
bool  edssBullCross = ta.crossover(edssStoch, edssSignal)
bool  edssBearCross = ta.crossunder(edssStoch, edssSignal)
bool  edssIsOB      = edssStoch > edssOB
bool  edssIsOS      = edssStoch < edssOS
bool  edssBullCurl  = edssBullCross and edssStoch[1] < edssOS   // Cross up FROM oversold
bool  edssBearCurl  = edssBearCross and edssStoch[1] > edssOB   // Cross down FROM overbought
float edssSlope     = edssStoch - edssStoch[1]
bool  edssRising    = edssSlope > 0
bool  edssFalling   = edssSlope < 0

// --- State Classification (dataset feature: edss_state) ---
// 0=OS‚Üì  1=OS‚Üë(curl)  2=MID‚Üë  3=MID‚Üì  4=OB‚Üë  5=OB‚Üì(curl)
int edssState = edssIsOS ? (edssRising ? 1 : 0) :
                edssIsOB ? (edssRising ? 4 : 5) :
                (edssRising ? 2 : 3)

//#endregion


//#region === MEASURED MOVE DETECTION ===

if showMeasuredMoves
    // TODO: Implement measured move detection
    // - Identify equal-length price swings using swing pivots
    // - Draw projected targets
    // - Return MeasuredMove UDTs
    if debugMode
        log.info("Measured Moves module active")

//#endregion


//#region === AUTO-FIBONACCI ENGINE (Multi-Period Confluence) ===

// Replaces ZigZag-based anchor with Fibonacci-sequence lookback periods.
// Matches TSoFib (Fibonacci Fractal MTF Confluence) methodology:
//   For each period N in [8, 13, 21, 34, 55]:
//     highN = ta.highest(high, N), lowN = ta.lowest(low, N)
//     Derive 0.382 / 0.5 / 0.618 retracements from that range
//   Select the anchor whose retracements have the most cross-period agreement.
//   Direction: isBullish when close >= 0.5 level of winning anchor.

var bool fibIsBullish = true
fibExtend = fibExtendRight ? extend.right : extend.none

// --- Compute high/low for each Fibonacci lookback period ---
fibHigh8  = ta.highest(high, 8)
fibLow8   = ta.lowest(low,   8)
fibHigh13 = ta.highest(high, 13)
fibLow13  = ta.lowest(low,   13)
fibHigh21 = ta.highest(high, 21)
fibLow21  = ta.lowest(low,   21)
fibHigh34 = ta.highest(high, 34)
fibLow34  = ta.lowest(low,   34)
fibHigh55 = ta.highest(high, 55)
fibLow55  = ta.lowest(low,   55)

// --- Score each anchor by counting cross-period confluences at 0.382 / 0.5 / 0.618 ---
// Tolerance: 0.1% of the anchor range
_fibScore(float h, float l) =>
    float rng = h - l
    if rng <= 0
        0
    else
        float tol = rng * 0.001
        int score = 0
        // Compare anchor's mid levels against all other periods' mid levels
        for ratio = 0 to 2
            float targetRatio = ratio == 0 ? 0.382 : ratio == 1 ? 0.5 : 0.618
            float levelSelf = l + rng * targetRatio
            // Period 8
            float r8 = fibLow8 + (fibHigh8 - fibLow8)
            for r = 0 to 2
                float cmpRatio = r == 0 ? 0.382 : r == 1 ? 0.5 : 0.618
                float cmpLvl = fibLow8 + (fibHigh8 - fibLow8) * cmpRatio
                if math.abs(levelSelf - cmpLvl) <= tol
                    score += 1
            // Period 13
            for r = 0 to 2
                float cmpRatio = r == 0 ? 0.382 : r == 1 ? 0.5 : 0.618
                float cmpLvl = fibLow13 + (fibHigh13 - fibLow13) * cmpRatio
                if math.abs(levelSelf - cmpLvl) <= tol
                    score += 1
            // Period 21
            for r = 0 to 2
                float cmpRatio = r == 0 ? 0.382 : r == 1 ? 0.5 : 0.618
                float cmpLvl = fibLow21 + (fibHigh21 - fibLow21) * cmpRatio
                if math.abs(levelSelf - cmpLvl) <= tol
                    score += 1
            // Period 34
            for r = 0 to 2
                float cmpRatio = r == 0 ? 0.382 : r == 1 ? 0.5 : 0.618
                float cmpLvl = fibLow34 + (fibHigh34 - fibLow34) * cmpRatio
                if math.abs(levelSelf - cmpLvl) <= tol
                    score += 1
            // Period 55
            for r = 0 to 2
                float cmpRatio = r == 0 ? 0.382 : r == 1 ? 0.5 : 0.618
                float cmpLvl = fibLow55 + (fibHigh55 - fibLow55) * cmpRatio
                if math.abs(levelSelf - cmpLvl) <= tol
                    score += 1
        score

score8  = _fibScore(fibHigh8,  fibLow8)
score13 = _fibScore(fibHigh13, fibLow13)
score21 = _fibScore(fibHigh21, fibLow21)
score34 = _fibScore(fibHigh34, fibLow34)
score55 = _fibScore(fibHigh55, fibLow55)

// --- Select best anchor (highest confluence score; tie ‚Üí largest period) ---
bestScore = math.max(score8, score13, score21, score34, score55)
fibAnchorHigh = bestScore == score8  ? fibHigh8  :
                bestScore == score13 ? fibHigh13 :
                bestScore == score21 ? fibHigh21 :
                bestScore == score34 ? fibHigh34 : fibHigh55
fibAnchorLow  = bestScore == score8  ? fibLow8   :
                bestScore == score13 ? fibLow13  :
                bestScore == score21 ? fibLow21  :
                bestScore == score34 ? fibLow34  : fibLow55

// --- Direction: bullish when close >= midpoint of best anchor ---
float fibMidpoint = fibAnchorLow + (fibAnchorHigh - fibAnchorLow) * 0.5
fibIsBullish := close >= fibMidpoint

// --- Compute level prices (direction-aware) ---
float fibRange = fibAnchorHigh - fibAnchorLow
float fibBase  = fibIsBullish ? fibAnchorLow : fibAnchorHigh
float fibDir   = fibIsBullish ? 1.0 : -1.0

_fibPrice(float ratio) => fibBase + fibDir * fibRange * ratio

// --- Drawing Helpers ---
_fibDrawLine(float price, color col) =>
    var id = line.new(bar_index, price, bar_index, price, color=color(na), width=1)
    if not na(price)
        line.set_xy1(id, bar_index - 55, price)
        line.set_xy2(id, bar_index, price)
        line.set_color(id, col)
        line.set_extend(id, fibExtend)
    else
        line.set_color(id, color(na))
    id

_fibDrawLabel(float price, string txt, color col) =>
    var id = label.new(x=bar_index, y=price, text="", textcolor=color(na), style=label.style_label_left, textalign=text.align_left, color=#00000000, size=size.small)
    if not na(price)
        label.set_xy(id, bar_index, price)
        label.set_text(id, txt)
        label.set_textcolor(id, col)
    else
        label.set_textcolor(id, color(na))

_fibTxt(float ratio, float price) =>
    string lv = fibShowLevels ? str.tostring(ratio) : ""
    string pr = fibShowPrices ? " (" + str.tostring(price, format.mintick) + ")" : ""
    lv + pr

_fibDrawLevel(bool show, float ratio, color col, line prev) =>
    float price = _fibPrice(ratio)
    bool vis = show and showAutoFib
    lineId = _fibDrawLine(price, vis ? col : color(na))
    _fibDrawLabel(price, vis ? _fibTxt(ratio, price) : "", vis ? col : color(na))
    if vis
        if not na(prev)
            linefill.new(lineId, prev, color=color.new(col, fibBgTransparency))
        lineId
    else
        prev

// --- Draw All Levels ---
ln0    = _fibDrawLevel(true,              0.0,   #787b86, line(na))
ln236  = _fibDrawLevel(true,              0.236, #f44336, ln0)
ln382  = _fibDrawLevel(true,              0.382, #81c784, ln236)
ln5    = _fibDrawLevel(true,              0.5,   #4caf50, ln382)
ln618  = _fibDrawLevel(true,              0.618, #009688, ln5)
ln786  = _fibDrawLevel(true,              0.786, #64b5f6, ln618)
ln1    = _fibDrawLevel(true,              1.0,   #787b86, ln786)
ln1236 = _fibDrawLevel(fibShowExtensions, 1.236, #81c784, ln1)
ln1618 = _fibDrawLevel(fibShowExtensions, 1.618, #2962ff, ln1236)

if showAutoFib and debugMode
    log.info("Multi-Period Fib active ‚Äî best score: " + str.tostring(bestScore) + " dir: " + (fibIsBullish ? "BULL" : "BEAR"))

//#endregion


//#region === BREAK-HOOK-GO METHODOLOGY ===

// --- BHG State ---
var int   bhgBreakBar      = int(na)
var float bhgBreakLevel    = na
var bool  bhgBreakBull     = true
var bool  bhgHookDone      = false
var int   bhgSignalCount   = 0
var int   bhgPullbackCount = 0

if showBreakHookGo
    bool haveStructure = not na(latestSwingHighPrice) and not na(latestSwingLowPrice)

    if haveStructure
        // =====================
        // BREAK Detection
        // =====================
        // Bullish break: close crosses above the latest swing high
        bool bullBreak = ta.crossover(close, latestSwingHighPrice)
        // Bearish break: close crosses below the latest swing low
        bool bearBreak = ta.crossunder(close, latestSwingLowPrice)

        if bullBreak
            bhgBreakBar   := bar_index
            bhgBreakLevel := latestSwingHighPrice
            bhgBreakBull  := true
            bhgHookDone   := false
            bhgSignalCount += 1

        if bearBreak
            bhgBreakBar   := bar_index
            bhgBreakLevel := latestSwingLowPrice
            bhgBreakBull  := false
            bhgHookDone   := false
            bhgSignalCount += 1

        // =====================
        // HOOK (Pullback) Detection
        // =====================
        // After a break, look for price to retrace back toward the broken level
        bool inBreakWindow = not na(bhgBreakBar) and (bar_index - bhgBreakBar) <= bhgSensitivity * 5 and not bhgHookDone

        if inBreakWindow
            // Pullback signal: price retraces to within threshold of the broken level
            bool pullbackToLevel = false
            if bhgBreakBull
                pullbackToLevel := low <= bhgBreakLevel * (1.0 + bhgPullbackFib * 0.01) and close > bhgBreakLevel * 0.998
            else
                pullbackToLevel := high >= bhgBreakLevel * (1.0 - bhgPullbackFib * 0.01) and close < bhgBreakLevel * 1.002

            if pullbackToLevel
                bhgHookDone := true
                bhgPullbackCount += 1

        // =====================
        // GO (Continuation Confirmation)
        // =====================
        // After hook, confirm continuation in the break direction
        bool goWindow = bhgHookDone and not na(bhgBreakBar) and (bar_index - bhgBreakBar) <= bhgSensitivity * 10

        if goWindow
            bool goSignal = false
            float bodySize = math.abs(close - open)
            float avgBody  = ta.sma(math.abs(close - open), 10)
            // EDSS momentum gate: prevent GO when oscillator is exhausted
            bool edssConfirmsBull = edssRising and not edssIsOB
            bool edssConfirmsBear = edssFalling and not edssIsOS
            if bhgBreakBull
                // Bullish go: strong close above break level with above-average body + EDSS rising
                goSignal := close > bhgBreakLevel and close > open and close > high[1] and bodySize > avgBody * 0.8 and edssConfirmsBull
            else
                // Bearish go: strong close below break level with above-average body + EDSS falling
                goSignal := close < bhgBreakLevel and close < open and close < low[1] and bodySize > avgBody * 0.8 and edssConfirmsBear

            if goSignal
                bhgSignalCount += 1
                bhgHookDone := false  // Reset so we don't fire multiple GOs
                bhgBreakBar := int(na)

    if debugMode
        log.info("Break-Hook-Go module active ‚Äî signals: " + str.tostring(bhgSignalCount) + " pullbacks: " + str.tostring(bhgPullbackCount))

//#endregion


//#region === CORRELATION ANALYSIS ===

if showCorrelation
    // TODO: Implement correlation analysis
    // - Dynamic requests for VIX, DXY, NQ (v6 feature)
    // - Rolling correlation coefficients
    // - Divergence/convergence signals
    if debugMode
        log.info("Correlation Analysis module active")

//#endregion


//#region === RISK MANAGEMENT ===

if showRiskManagement
    // TODO: Implement risk management
    // - Position sizing based on account size and risk %
    // - Stop loss placement from fib/structure levels
    // - R:R calculation and display
    if debugMode
        log.info("Risk Management module active")

//#endregion


//#region === VISUALIZATION & PLOTTING ===

// --- Debug Dashboard ---
if debugMode
    var table debugTable = table.new(position.top_right, 2, 14, bgcolor=color.new(color.black, 80), border_width=1)
    table.cell(debugTable, 0, 0, "Module",       text_color=color.white, text_size=size.small)
    table.cell(debugTable, 1, 0, "Status",       text_color=color.white, text_size=size.small)
    table.cell(debugTable, 0, 1, "Measured Moves", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 1, showMeasuredMoves ? "ON" : "OFF", text_color=showMeasuredMoves ? color.green : color.red, text_size=size.small)
    table.cell(debugTable, 0, 2, "Auto-Fib",     text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 2, showAutoFib ? "ON" : "OFF", text_color=showAutoFib ? color.green : color.red, text_size=size.small)
    table.cell(debugTable, 0, 3, "Break-Hook-Go", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 3, showBreakHookGo ? "ON" : "OFF", text_color=showBreakHookGo ? color.green : color.red, text_size=size.small)
    table.cell(debugTable, 0, 4, "Correlation",  text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 4, showCorrelation ? "ON" : "OFF", text_color=showCorrelation ? color.green : color.red, text_size=size.small)
    table.cell(debugTable, 0, 5, "Risk Mgmt",    text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 5, showRiskManagement ? "ON" : "OFF", text_color=showRiskManagement ? color.green : color.red, text_size=size.small)
    table.cell(debugTable, 0, 6, "Swing Highs",  text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 6, str.tostring(array.size(swingHighs)), text_color=color.orange, text_size=size.small)
    table.cell(debugTable, 0, 7, "Swing Lows",   text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 7, str.tostring(array.size(swingLows)),  text_color=color.orange, text_size=size.small)
    table.cell(debugTable, 0, 8, "Fib Direction", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 8, fibIsBullish ? "BULL" : "BEAR", text_color=fibIsBullish ? color.teal : color.red, text_size=size.small)
    table.cell(debugTable, 0, 9, "Fib Signals",  text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 9, str.tostring(fibSignalCount), text_color=color.yellow, text_size=size.small)
    table.cell(debugTable, 0, 10, "BHG Signals",  text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 10, str.tostring(bhgSignalCount), text_color=color.lime, text_size=size.small)
    table.cell(debugTable, 0, 11, "BHG Pullbacks", text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 11, str.tostring(bhgPullbackCount), text_color=color.aqua, text_size=size.small)
    table.cell(debugTable, 0, 12, "EDSS Value",   text_color=color.gray, text_size=size.small)
    table.cell(debugTable, 1, 12, str.tostring(edssStoch, "#.###"),
               text_color=edssIsOB ? color.red : edssIsOS ? color.green : color.blue,
               text_size=size.small)
    table.cell(debugTable, 0, 13, "EDSS State",   text_color=color.gray, text_size=size.small)
    string edssStateStr = edssState == 0 ? "OS‚Üì" : edssState == 1 ? "OS‚Üë" :
                          edssState == 2 ? "MID‚Üë" : edssState == 3 ? "MID‚Üì" :
                          edssState == 4 ? "OB‚Üë" : "OB‚Üì"
    table.cell(debugTable, 1, 13, edssStateStr,
               text_color=edssRising ? color.lime : color.red,
               text_size=size.small)

//#endregion
